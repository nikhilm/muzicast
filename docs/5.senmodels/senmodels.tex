\documentclass{article}
\begin{document}

\title{Software Engineering Models: A comparative study}

\author{Team 3}

\date{\today}

\maketitle

\newpage{}
\tableofcontents
\newpage{}

\newpage{}
\section{Rapid Application Development Model}
\subsection{Advantages of RAD}
\begin{itemize}
\item        Conventional software development methods take, on an average almost 20% more time than the RAD procedure. Using RAD can enable quicker visualization of the end-design and hence allow rapid software testing and rectifying steps. The customer is able to have a faster look at the design to add valuable inputs, in order to make the design more user-friendly.
\item        RAD reduces development time and reuses components to speed up development.
\item        It protects the current project from the variations in the market.
\item        RAD realizes an overall reduction in project risk.
\item        All the software prototypes produced can be kept in a repository for future use.
\item        RAD involves user participation thereby increasing chances of early user community acceptance.
\end{itemize}

\subsection{Disadvantages of RAD}
\begin{itemize}
\item        For large but scalable projects, RAD requires sufficient human resources to create the right number of RAD teams
\item        RAD requires equal commitment from the developers and customers towards the rapid development process.
\item        RAD cannot be applied to projects that cannot be properly modularized.
\item        RAD is not appropriate for areas using new technology
\item        RAD requires that the requirements are ?well understood? and that the project scope is ?constrained?.
\end{itemize}


\newpage{}
\section{Incremental Model}
\subsection{Advantages of Incremental}
\begin{itemize}
\item        Useful when staffing is unavailable for a complete implementation by the business deadline of the project
\item        Early increments can be implemented by fewer people, and depending on the acceptability of the core product, more resources can be added to implement subsequent stages.
\item        Increments can be planned to manage technical risks.
\item        Reduces the traumatic effect of imposing a completely new product on the client organization by providing a gradual introduction.
\item        Progress is visible, rather than being buried in documents.
\item        Distributes feedback throughout the whole development cycle, leading to more stable artifacts.
\end{itemize}

\subsection{Disadvantages of Incremental}
\begin{itemize}
\item        Each additional build has somehow to be incorporated into the existing structure without degrading the quality of what has been build to date.
\item        Clients see possibilities and want to change requirements.
\item        The process can be time consuming.
\item        Addition of succeeding builds must be easy and straightforward.
\item        The more the succeeding builds are the source of unexpected problems, the more the existing structure has to be reorganized, leading to inefficiency and degrading internal quality and degrading maintainability.
\end{itemize}


\newpage{}
\section{Evolutionary Model}
\subsection{Advantages of evolutionary}
\begin{itemize}
\item        User gets an opportunity to experiment/use the partial system much before the fully developed version is released.
\item        Constant customer involvement and validation.
\item        Core module gets tested very thoroughly.
\item        Entire resource requirements need not be committed to the project at the same time.
\end{itemize}

\subsection{Disadvantages of Evolutionary}
\begin{itemize}
\item        Use of the method is exploratory in nature and therefore constitutes a high-risk endeavour. Strong management is required.
\item        This method is used as an excuse for hacking to avoid documenting the requirements or design, even if they are well understood. 
\item        Users/acquirers do not understand the nature of the approach and can be disappointed when results are unsatisfactory.
\item        It is difficult to break down a system into functional units that can be implemented in an incremental fashion
\end{itemize}

\newpage{}
\section{Spiral Model}
\subsection{Advantages of Spiral Model}
\begin{itemize}
\item Repeated or continuous development helps in risk management. The developers or programmers describe the characteristics with high priority first and then develop a prototype based on these. This prototype is tested and desired changes are made in the new system. This continual and steady approach minimizes the risks or failure associated with the change in the system. Since each and every part of
the system is thought out and rigourously designed it is less liable to failure.
\item Adaptability in the design of spiral model in software engineering accommodates any number of changes, that may happen, during any phase of the project. Instead of doing design just once like the Waterfall model, this can incorporate any changes.
\item Since the prototype building is done in small fragments or bits, cost estimation becomes easy and the customer can gain control on administration of the new system.
\item As the model continues towards final phase, the customer's expertise on new system grows, enabling smooth development of the product meeting client's needs. Thus the user experience is not changed in a jarring fashion.
\end{itemize}

\subsection{Disadvantages of Spiral Model}
\begin{itemize}
\item Spiral models work best for large projects only, where the costs involved are much higher and system pre requisites involves higher level of complexity. This is because spiral model iterations are on the scale of months, with sufficient complexity to demand many domain experts.
\item Spiral model needs extensive skill in evaluating uncertainties or risks associated with the project and their abatement.
\item Spiral models work on a protocol, which needs to be followed strictly for its smooth operation. Sometimes it becomes difficult to follow this protocol due to the human element of mundane tasks being done carelessly.
\item Evaluating the risks involved in the project can shoot up the cost and it may be higher than the cost for building the system.
\item There is a requirement for further explanation of the steps involved in the project such as breakthrough, blueprint, checkpoints and standard procedure.
\end{itemize}

\newpage{}
\section{Concurrent Development}
\subsection{Advantages of Concurrent Development Model}
\begin{itemize}
\item \emph{Activity concurrency} and \emph{Information concurrency} leads to integrated development in which all the concerns
of the different stakeholders are addressed through a flow of shared information.
\item \emph{Across project overlap} within an organization allows reuse of code. Design of two parallel products can happen much
faster.
\item Front-loading of information, i.e. allowing activities of later functions like process engineering to interact with initial
stages like requirements gathering allows painting a realistic scenario and stops unforeseen problems from becoming major show-stoppers.
\item In combined software and hardware projects, the two-way interchange of information advocated by the Concurrent model can
ease any problems of integration which may arise.
\item As information is produced partially by earlier stages, later stages can start using it to get a rough idea about their job reducing final development time.
\end{itemize}

\subsection{Disadvantages of Concurrent Development Model}
\begin{itemize}
\item Changes and rework affect all stages of the project since everyone has started working.
\item Increased communication flows means that significant time is invested in managing the communication itself. This puts a limit
on the number of concurrent activities that can occur.
\item Concurrent Development is best suited to short development cycles where any rework required is not too much. This may not match
with large projects where short development cycles might not be possible.
\end{itemize}

\newpage{}
\section{Model used for Muzicast}

Muzicast the music streaming server, features a distinct set of features. So we will be using the natural fit, which is the \emph{incremental evolutionary model}. We believe this is justified because we can break down our project into these three distinct layers, each
of which will be implemented in the following order:

\begin{itemize}
\item Core functionality of scanning collection, having the streaming server, and giving visitors the ability to create \emph{one} playlist which persists only for that session.
\item Adding capability to register as user and have multiple playlists which persist.
\item Add discovery features, like search, keeping track of top played\\ tracks/albums/artists.
\item Browse, clone and modify other users public playlists.
\end{itemize}

In each phase, we will be following a simple prototype based design approach in which we will only create wireframe/rough mockups of our interface. This will aid us because all user interaction in our case is through the web interface and the flow of the user for certain actions will aid us in our requirements gathering and system design. We will soon update our roadmap for the project to accomodate these 4 phases instead of the simple waterfall model we had planned earlier.

\end{document}
